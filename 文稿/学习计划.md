## Git——分布式版本控制系统

记录、跟踪、整合文件的变化

分布式：每个电脑就是一个完整的版本库，每次只推送修改的内容到其他电脑

集中式：所有的电脑连接中央服务器，从上面取得最新版本，修改后推送到中央服务器

#### 概念

git包含工作区、版本库

工作区即仓库所在目录

仓库目录中包含.git目录，即版本库

版本库包含暂存区stage、分支Master、指向Master的指针HEAD

![1548605302373](F:\github.io\CoerLi.github.io\文稿\git结构.png)

#### 操作

**git init            将当前目录初始化为仓库**

**git add filename 		将文件加入到仓库**

**git commit -m message 		提交已加入的文件到仓库**

**git status 	查看仓库文件状态**

**git diff      	查看改变的情况**

**git log      	查看历次提交情况**

git reset 	回滚历史版本，可以使用HEAD，也可以指定版本号

git reflog  	产看历史命令

git checkout   -- filename    用版本库的文件替换工作区的文件

git reset HEAD filename      撤回add进暂存区的内容，回到工作区

git rm        删除文件，命令进入暂存区，也需要commit后才能生效，commit后版本库也没有文件了

**git remote add origin [git@server-name:path/repo-name.git](mailto:git@server-name:path/repo-name.git)**

**将本地仓库关联到远程仓库，其中origin是定义的远程仓库名称**

git push -u origin master 第一次推送分支的所有内容

git push origin master    推送更新的内容

**git clone + url      克隆远程仓库到本地**

分支：

**git branch      查看当前分支**

**git branch name       新建分支**

**git checkout name    切换分支**

git branch -d       删除分支

git branch -D       强制删除未合并的分支

分支提交的内容不会影响其他分支

**git merge 分支         将指定分支合并到当前分支**

两个分支修改了不同的内容后，合并时会起冲突需要手动更改冲突的内容。

git默认为fast forward，merge时会将分支信息全部删除，工作中可以使用git merge –no-ff    ，这样会禁用fast forward，保留分支信息

git stash 存储当前分支现场

git stash list 查看存储的分支

git stash apply + 指定分支        将现场恢复

git push origin  将分支push到远程仓库

git checkout -b dev origin/dev       clone远程仓库的分支

**git pull 从远程仓库中拉取代码**

拉取代码时需要建立本地分支与远程分支的链接

git branch --set-upstream-to <branch-name> origin/<branch-name>

拉取时会自动合并，合并时产生冲突需要修复

多人合作流程：

1、        push自己的修改

2、        失败则说明远程分支比本地更新，需要pull后合并

3、        合并产生冲突，修复

4、        修复后再次push

tag：默认对本次提交打tag

**git tag v1.0     对本次提交打tag**

对过往的commit打标签时，可以先通过log查找对应id

git tag -a v0.1 -m "version 0.1 released" 1094adb

tag还可以备注信息

git push origin v1.0   推送tag到远程仓库

·        命令git push origin <tagname>可以推送一个本地标签；

·        命令git push origin --tags可以推送全部未推送过的本地标签；

·        命令git tag -d <tagname>可以删除一个本地标签；

·        命令git push origin :refs/tags/<tagname>可以删除一个远程标签。

## Maven

maven 创建项⽬

```xml
mvn archetype:generate 
//使用generate生成maven骨架

-DgroupId=cn.codingxiaxw.helloword 
//groupId，项目组织名称

-DartifactId=helloworld
//artifactId，具体项目名 

-Dpackage=cn.codingxiaxw.helloword 
//项目包名，可选填，与项目组名称保持一致

-Dversion=1.0-SNAPSHOT 
//版本号，

-DarchetypeArtifactId=maven-archetype-quickstart
//项目结构，quickstart/webapp
```

### pom结构

不可缺少的四部分：

modelVersion：4.0.0       pom模版文件的版本

groupId    项目组织名

artifactId   具体项目名称

version      项目的版本号

 

### 配置maven私服 

#### plugin 

maven本身不执行任务，它是一个插件框架，所有的任务都由插件执行。一个插件可能有多个插件目标，例如complie:complile指的是complie插件的complie目标。

插件工作有两种方式：

第一种是绑定到生命周期的phase上，例如执行clean生命周期执行clean插件。

第二种是通过命令调用插件。例如:clean:clean

除了默认的插件，其他的插件需要在pom中引入

```xml
<build>
    <plugins>
      <plugin>
        <!-- groupId artifactId version 是maven的坐标 -->
       <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-source-plugin</artifactId>
        <version>2.1.1</version>
        <executions>
          <execution>
            <id>attach-sources</id>
            <phase>verify</phase>
            <goals>
              <goal>jar-no-fork</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
    </plugins>
</build>
```

### build      构建处理

build分为两种，project build全局配置  和porfile build

```
build    基本元素
<defaultGoal>install                   默认mvn时执行的任务，
即mvn = mvn install
<directory> ${basedir}/target          生成结果的目录
<filename>                             生成结果的名称
```

### package     打包

项目编译、测试、打包，包放到本地target中

### install     安装

项目编译、测试、打包，包放到本地target，再部署到本地仓库

### clean     清理

清理项目中target文件夹

### deploy   部署

编译、测试、打包、包放到本地target、部署到本地仓库和远程仓库

### dependencies tree    解决jar包冲突问题

引入大量依赖可能产生的问题：

1、        引入同一个jar包的不同版本，造成冲突、

2、        有些版本的jar包因为重名未被加载，但是却需要

```xml
使用dependency:tree可以查询jar的加载情况
compile  正常加载
omitted for duplicate      同一个版本的jar重复加载了
omitted for conflict with 1.8.3        和已经加载的1.8.3冲突了

解决方法：
<dependency>标签内有<exclusions>标签，可以排除本依赖中的部分jar包。
```

https://www.cnblogs.com/mingzhanghui/p/9412862.html