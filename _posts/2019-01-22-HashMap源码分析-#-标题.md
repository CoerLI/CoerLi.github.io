---
layout:     post   				          # 使用的布局（不需要改）
title:      HashMap源码分析				   # 标题 
subtitle:   快速理解HashMap设计原理          #副标题
date:       2019-01-22 				      # 时间
author:     Lih 						  # 作者
header-img: img/view05.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - Java集合
    - 源码分析

---

# HashMap

### 基本属性

```java
// 默认初始容量：16，必须为2的幂，此处后面会用到
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; 
// 默认最大容量，2^30
static final int MAXIMUM_CAPACITY = 1 << 30;
// 默认负载因子0.75，指的是。。。
static final float DEFAULT_LOAD_FACTOR = 0.75f;
// 链表上的元素>8时树化
static final int TREEIFY_THRESHOLD = 8;
// 逆树化：当树的元素<=6时会变成链表(只有在分裂时会变)
static final int UNTREEIFY_THRESHOLD = 6;
// 树化时最小hash表的容量，当hash表的容量小于MIN_TREEIFY_CAPACITY时，不会树化，只会发生resize
static final int MIN_TREEIFY_CAPACITY = 64;
```

### 重要方法

```java
// 通过hash()方法的返回值来散列，所以hash方法直接影响hash表性能
static final int hash(Object key) {
	int h;
    // 这里是将hashCode的高16位与低16位相与
	return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

为何要通过hash()方法获得一个新的hashCode？

​	原因：增加低位的离散程度，减少hash冲突	

​	HashMap取得桶位置的方法是：

```java
//jdk1.8 中的HashMap没有专门的取索引方法，以下是伪代码
key.hash() & (table.length - 1)
```

​	由于数组length一般较短，当length和hashCode相与时只能利用到低位，那么高位无法影响散列的结果。但是通过hash()方法，高位与低位相与，增加低位离散程度的同时，保留了高位对散列结果的影响。

**——————————————————————————————————————————————**

```java
final Node<K,V> removeNode(int hash, Object key, Object value,
                               boolean matchValue, boolean movable) {
	Node<K,V>[] tab; Node<K,V> p; int n, index;
	if ((tab = table) != null && (n = tab.length) > 0 &&
		(p = tab[index = (n - 1) & hash]) != null) {
		Node<K,V> node = null, e; K k; V v;
        if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                node = p;
		else if ((e = p.next) != null) {
			if (p instanceof TreeNode)
                    node = ((TreeNode<K,V>)p).getTreeNode(hash, key);
			else {
				do {
					if (e.hash == hash &&
						((k = e.key) == key ||
							(key != null && key.equals(k)))) {
                            node = e;
                            break;
					}
                    p = e;
                    } while ((e = e.next) != null);
                }
            }
            if (node != null && (!matchValue || (v = node.value) == value ||
                                 (value != null && value.equals(v)))) {
                if (node instanceof TreeNode)
                    ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);
                else if (node == p)
                    tab[index] = node.next;
                else
                    p.next = node.next;
                ++modCount;
                --size;
                afterNodeRemoval(node);
                return node;
            }
		}
		return null;
	}
```



