---
layout:     post   			                  # 使用的布局（不需要改）
title:      JVM：垃圾回收                 # 标题 
subtitle:   学习JVM垃圾回收算法及收集器           #副标题
date:       2019-01-22 				           # 时间
author:     Lih 						             # 作者
header-img: img/view03.jpg 	       #这篇文章标题背景图片
catalog: true 						               # 是否归档
tags:								                     #标签
    - JVM
---

##GC条件：GC垃圾对象

**垃圾**：没有任何引用指向的对象或者在程序中无用的对象（因为有可能出现循环引用）。

### 如何确定垃圾：

1、引用计数：记录每个对象的被引用数目。

​	问题：出现循环引用

2、正向可达：从roots对象计算，可以到达的对象即不是垃圾

### 拓展：什么对象可以作为roots对象

roots对象： 1、栈中引用的对象

​                    2、方法区静态属性、常量引用的对象

​                    3、本地方法栈引用的对象

## 堆内存分区：新生代+老年代

![1551712599609](C:\Users\lihang\Desktop\专项\1551712599609.png)

Eden：新对象（太大则直接进入old）

Survivor From / To：同时只有一个Survivor是空的，两者交换。

Old：存储new晋升上来的+大对象

## 垃圾回收流程：

## 垃圾回收算法：

### 标记清除（Mark-Sweep）：

标记垃圾，标记垃圾，清除垃圾部分的数据

结果：碎片化严重，由于对象分配需要连续的内存，内部不足引发Full GC

### 标记整理（Mark-Compact）：老年代使用——原因：GC少，不考虑效率

标记垃圾，清除后将存活的对象整理

结果：效率低（多一步整理）

### 复制算法（Copying）：新生代使用

每次使用一半空间，空间不足时，将有效的对象复制到另一半空间并且整理，并且完整擦除原来的一半空间

结果：效率高（因为完整擦除耗时短），空间利用率低（一次只能用一半空间）

### JVM：分代算法（策略）

新生代：复制算法，因为频繁GC需要提高GC效率

老年代：标记整理（MC），因为GC少，不关注GC效率，只需要利用率高

## 垃圾收集器