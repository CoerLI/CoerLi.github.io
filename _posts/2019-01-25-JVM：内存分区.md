---
layout:     post   			                  # 使用的布局（不需要改）
title:      JVM 内存分区                 # 标题 
subtitle:   学习JVM内存分区情况           #副标题
date:       2019-01-25 				           # 时间
author:     Lih 						             # 作者
header-img: img/view04.jpg 	       #这篇文章标题背景图片
catalog: true 						               # 是否归档
tags:								                     #标签
    - JVM
---

##  内存结构

![1551696979291](C:\Users\lihang\Desktop\专项\1551696979291.png)	

### 方法区（线程公有）：类信息、静态变量（static对象）、方法信息、引用、常量池

类加载器找到class文件（即：字节码文件），加载进JVM，JVM提取类信息，并且存储到方法区中。

方法区存放了要加载的**类的信息**（如类名、修饰符等）、静态变量、构造函数、final定义的常量、类中的字段和方法等信息+**运行时常量池**。

运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存储编译器生成的常量（基本类型、String）和常量对象引用。

方法区GC主要针对**常量池的回收**和**已加载类的卸载**。

### 堆（线程公有）：

堆内存由所有线程共享，主要用于存放对象实例及数组，所有new出来的对象都存储在该区域，线程在栈帧中通过方法内部的引用来调用对象。

### 虚拟机栈（线程私有）：

每个线程有一个私有、独立的虚拟机栈空间，当线程结束时，空间也会消失。每个线程执行方法时，会在自己的空间内创建一个栈帧（一个栈有多个栈帧，每个栈帧的大小是固定的，栈帧内存储局部变量表，变量表内存储基本的数据类型和对象引用，局部变量表的所需的内存空间在编译器完成分配，操作数栈，动态链接，方法出口），方法的递归调用就会引起栈帧过多，导致StackOverflow。注：new出来的对象存储在栈帧中。

### 本地方法栈（线程私有）：

当一个线程执行本地方法时，不再往虚拟机栈中压栈（即：创建栈帧），而是在本地方法栈中执行JNI（也类似于虚拟机栈和栈帧，只不过方法是本地方法）。

### 程序计数器（线程私有）：无 OOM 区域

当前线程执行到的字节码的行号，切换线程时通过这个行号恢复线程，当执行Native方法时，指针指空。

## 堆内存分区：新生代+老年代

![1551712599609](C:\Users\lihang\Desktop\专项\1551712599609.png)

Eden：新对象（太大则直接进入old）

Survivor From / To：同时只有一个Survivor是空的，两者交换。

Old：存储new晋升上来的+大对象

## GC条件：GC垃圾对象

**垃圾**：没有任何引用指向的对象或者在程序中无用的对象（因为有可能出现循环引用）。

### 如何确定垃圾：

1、引用计数：记录每个对象的被引用数目。

​	问题：出现循环引用

2、正向可达：从roots对象计算，可以到达的对象即不是垃圾

### 拓展：什么对象可以作为roots对象

roots对象： 1、栈中引用的对象

​                    2、方法区静态属性、常量引用的对象

​                    3、本地方法栈引用的对象

## 垃圾回收算法：

### 标记清除（Mark-Sweep）：

标记垃圾，标记垃圾，清除垃圾部分的数据

结果：碎片化严重，由于对象分配需要连续的内存，内部不足引发Full GC

### 标记整理（Mark-Compact）：老年代使用——原因：GC少，不考虑效率

标记垃圾，清除后将存活的对象整理

结果：效率低（多一步整理）

### 复制算法（Copying）：新生代使用

每次使用一半空间，空间不足时，将有效的对象复制到另一半空间并且整理，并且完整擦除原来的一半空间

结果：效率高（因为完整擦除耗时短），空间利用率低（一次只能用一半空间）

### JVM：分代算法（策略）

新生代：复制算法，因为频繁GC需要提高GC效率

老年代：标记整理（MC），因为GC少，不关注GC效率，只需要利用率高

## 垃圾收集器